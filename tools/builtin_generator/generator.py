import argparse
import os
from datetime import datetime
from pathlib import Path
from pprint import pformat

import black
import yaml

from .library import Library
from .tags import TagKind


def main():
    arg_parser = argparse.ArgumentParser()
    arg_parser.add_argument("directory")
    arg_parser.add_argument("--skip-build", dest="build", action="store_false")
    args = arg_parser.parse_args()

    config_path = os.path.join(args.directory, "config.yaml")
    with open(config_path) as config_file:
        config = yaml.load(config_file, Loader=yaml.SafeLoader)

    buckets = {
        TagKind.MACRO: {},
        TagKind.EXTERN: {},
        TagKind.PROTOTYPE: {},
        TagKind.FUNCTION: {},
        TagKind.TYPEDEF: {},
        TagKind.UNION: {},
        TagKind.STRUCT: {},
        TagKind.MEMBER: {},
        TagKind.ENUM: {},
        TagKind.ENUMERATOR: {},
        TagKind.VARIABLE: {},
    }

    for library, data in config["libraries"].items():
        lib = Library(library, data["path"], data["includes"])
        if args.build:
            lib.build()
        tags = lib.tags()

        for tag in tags:
            if tag.name.startswith("__"):
                continue
            bucket = buckets[tag.kind]
            bucket[tag.name] = (tag, lib)

    header = (
        "\n".join(
            [
                "'''",
                f"This file was autogenerated by builtin_generator at {datetime.now()}.",
                "",
                "DO NOT MODIFY IT MANUALLY!",
                "'''",
            ]
        )
        + "\n\n"
    )

    types_path = Path(args.directory, "types.py")
    with types_path.open("w") as f:
        f.write(header)
        generate_types(f, config, buckets)

    for path in (types_path,):
        black.format_file_in_place(
            path, fast=True, mode=black.Mode(()), write_back=black.WriteBack.YES
        )


def generate_types(output, config, buckets):
    translations = {}
    paths = {}
    if "types" in config:
        for primitive in config["types"].get("signed"):
            rewritten = translate_typename(primitive)
            translations[rewritten] = primitive
            for prefix in ("signed", "unsigned"):
                translations[f"{rewritten}_{prefix}"] = f"{prefix} {primitive}"

        for primitive in config["types"].get("other"):
            rewritten = translate_typename(primitive)
            translations[rewritten] = primitive

    tags = extract(
        buckets,
        [
            TagKind.UNION,
            TagKind.STRUCT,
            TagKind.ENUM,
            TagKind.TYPEDEF,
        ],
    )
    for (tag, lib) in tags.values():
        name = f"{lib.name}::{tag.name}"
        if tag.kind in (TagKind.UNION, TagKind.STRUCT, TagKind.ENUM):
            translations[name] = f"{tag.kind} {tag.name}"
        else:
            translations[name] = tag.name
        paths[name] = tag.path

    contents = ""
    contents += f"TYPES = {pformat(translations)}\n\n"
    contents += f"PATH = {pformat(paths)}\n\n"
    output.write(contents)


def translate_typename(name: str) -> str:
    parts = name.split()
    parts.reverse()
    return "_".join(parts)


def extract(buckets, kinds):
    if kinds is None:
        return {}

    types = {}
    for kind in kinds:
        for (tag, lib) in buckets[kind].values():
            types[tag.name] = (tag, lib)

    return types


# variables = extract(
#     buckets,
#     [
#         TagKind.VARIABLE,
#         TagKind.EXTERN,
#     ],
#     LangVariable,
# )
# functions = extract(
#     buckets,
#     [
#         TagKind.FUNCTION,
#         TagKind.PROTOTYPE,
#     ],
#     LangFunction,
# )

# class LangVariable(Lang):
#     def __init__(self, tag: Tag, library: Optional[Library] = None):
#         super().__init__(tag, library)
#         self.type = " ".join(tag.typeref.split(":")).removeprefix("typename ")

# class LangFunction(Lang):
#     def __init__(self, tag: Tag, library: Optional[Library] = None):
#         super().__init__(tag, library)

#         try:
#             self.type = " ".join(tag.typeref.split(":")).removeprefix("typename ")
#         except AttributeError:
#             self.type = "void"
#         self.args = tag.signature
